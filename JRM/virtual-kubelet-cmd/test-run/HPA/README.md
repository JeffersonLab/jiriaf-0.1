# Testing Upscaling and Downscaling of Pods for VK using HPA of Kubernetes

This document describes the process of testing the upscaling and downscaling of pods for VK using the Horizontal Pod Autoscaler (HPA) of Kubernetes. Check the https://github.com/tsaie79/autoscaling-jiriaf for the complete code.

## Setup

The test setup involves a HTTP load balancer implemented in Go (`load_balancer.go`). This load balancer redirects HTTP requests to multiple HTTP servers, each implemented in Go (`server.go`).

The deployment of Kubernetes is defined by this HTTP server. This means that the number of replicas or pods creates several HTTP servers. The scaling of these pods is managed by the HPA.

## Load Generation

The load of HTTP requests is generated by the `hey` application, which is invoked by the bash script `add-load.sh`.

## Test Results

The results of the test demonstrate that the HPA works for VK, including the upscaling and downscaling of pods. When the load increases, the HPA increases the number of pods to handle the load (upscaling). When the load decreases, the HPA reduces the number of pods (downscaling).

## Load Balancer

The load balancer is implemented in Go and is defined in `load_balancer.go`. It maintains a list of servers and forwards incoming requests to these servers in a round-robin fashion. If a server is down, it is removed from the list. New servers can be added to the list through the `/register` endpoint.

Here is the complete code for the load balancer:

```go
package main

import (
    "container/list"
    "net/http/httputil"
    "net/http"
    "net/url"
    "net"
)

var servers *list.List

func helloHandler(w http.ResponseWriter, r *http.Request) {
    for e := servers.Front(); e != nil; e = e.Next() {
        server := e.Value.(*url.URL)

        conn, err := net.Dial("tcp", server.Host)
        if err != nil {
            // remove the server from the list
            next := e.Next()
            servers.Remove(e)
            e = next
            continue
        }

        conn.Close()

        proxy := httputil.NewSingleHostReverseProxy(server)
        proxy.ServeHTTP(w, r)

        // Move the server to the back of the list
        servers.MoveToBack(e)
        break
    }

    if servers.Len() == 0 {
        http.Error(w, "No servers available", http.StatusInternalServerError)
        return
    }
}

func registerHandler(w http.ResponseWriter, r *http.Request) {
    serverURL, err := url.Parse(r.URL.Query().Get("url"))
    if err != nil {
        http.Error(w, "Invalid server URL", http.StatusBadRequest)
        return
    }

    servers.PushBack(serverURL)
}

func listServersHandler(w http.ResponseWriter, r *http.Request) {
    for e := servers.Front(); e != nil; e = e.Next() {
        server := e.Value.(*url.URL)
        w.Write([]byte(server.String() + "\n"))
    }
}

func main() {
    servers = list.New()

    http.HandleFunc("/", helloHandler)
    http.HandleFunc("/register", registerHandler)
    http.HandleFunc("/list", listServersHandler)
    http.ListenAndServe(":8080", nil)
}
```
## HTTP Server

The HTTP server is implemented in Go and is defined in `server.go`. It has single endpoint:

- `/` which responds with "Hello, World!"

The server registers itself with the load balancer upon startup.

Here is the complete code for the server:

```go
package main

import (
	"fmt"
	"net/http"
	"net/url"
	"os"
	"net"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "Hello, World!")
}

func main() {
	http.HandleFunc("/", helloHandler)

	listener, err := net.Listen("tcp", "localhost:0") 
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to listen: %v\n", err)
		os.Exit(1)
	}

	serverURL := url.URL{
		Scheme: "http",
		Host:   listener.Addr().String(),
	}

	go func() {
		_, err = http.Get("http://localhost:8080/register?url=" + url.QueryEscape(serverURL.String()))
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to register with load balancer: %v\n", err)
			os.Exit(1)
		}
	}()

	fmt.Printf("Server is listening on %s\n", listener.Addr().String())
	http.Serve(listener, nil)
}
```
## Load Generation
`hey` is a HTTP load generator that is used to generate the load. To install `hey`, run the following command: `go install github.com/rakyll/hey@latest`.

Here is the bash script `add-load.sh` that generates the load. 
```bash
#!/bin/bash
./hey -n 3000000 -c 1 http://localhost:8080/
```


## Deployment and HPA yaml files for Kubernetes
Here is the deployment file `deployment.yaml` for the HTTP server:
```yaml
kind: ConfigMap
apiVersion: v1
metadata:
  name: http-server
data:
  http-server.sh: |
    #!/bin/bash
    $SERVER_BIN/server

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: c
spec:
  # replicas: 1
  selector:
    matchLabels:
      app: c
  template:
    metadata:
      labels:
        app: c
    spec:
      containers:
        - name: c1
          image: http-server
          command: ["bash"]
          args: [""]
          env:
            - name: SERVER_BIN
              value: ~/JIRIAF/virtual-kubelet-cmd/test-run/HPA/load
          volumeMounts:
            - name: http-server
              mountPath: stress/job1
          resources:
            requests:
              cpu: "1"
              memory: "7Mi"
            limits:
              cpu: "8"
              memory: "10Mi"

      volumes:
        - name: http-server 
          configMap:
            name: http-server
      nodeSelector:
        kubernetes.io/role: agent
        kubernetes.io/hostname: vk
      tolerations:
        - key: "virtual-kubelet.io/provider"
          operator: "Equal"
          value: "mock"
          effect: "NoSchedule"
      restartPolicy: Always
```

Here is the HPA file `hpa.yaml`:
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler

metadata:
  name: c
  namespace: default

spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: c
  minReplicas: 1
  maxReplicas: 10
  metrics:
  # - type: Resource
  #   resource:
  #     name: memory
  #     target:
  #       type: Utilization
  #       averageUtilization: 50
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 30
```